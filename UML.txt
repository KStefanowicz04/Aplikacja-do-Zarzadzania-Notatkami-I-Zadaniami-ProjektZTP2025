@startuml



' ENUMY
enum Priorytet {
  Niski
  Sredni
  Wysoki
}



' KLASY
' Abstrakcyjna Fabryka Wpisów - dziedziczą z niej dwie fabryki Notatek i Zadań
abstract class FabrykaWpisów <<Factory Method>> {
    # FabrykaWpisów()
    + UtwórzWpis(tytuł: string, treść: string, nazwyTagów: List<string>)
    + UtwórzWpis(tytuł: string, treść: string, priorytet: Priorytet, termin: DateTime, nazwyTagów: List<string>, )
}

' Interfejs Wpisu - potrzebny do dekoratorów
interface IWpis {
    WypiszInformacje(): string
}

' Wpis - klasa abstrakcyjna z której dziedziczą Notatka i Zadanie.
' Ma ID, tytuł, treść, timestampy, tagi.
' Można je edytować, Tagi można dodawać i usuwać.
abstract class Wpis {
    - id: int
    - tytuł: string
    - treść: string
    - dataUtworzenia: DateTime
    - dataModyfikacji: DateTime
    - tagi: List<Tag>

    # Wpis(tytuł: string, treść: string) : IWpis
    + Edytuj(tytuł: string, treść: string, priorytet: Priorytet, termin: DateTime): void
    + DodajTag(tag: Tag): void
    + UsuńTag(tag: Tag): void
    + WypiszInformacje(): string
}


' Menedżer notatek - tworzy, usuwa, wyszukuje notatki.
' Wyszukać można po ID, po treści notatki (w tym po tytule, to jedna funkcja!),
' po tagach danej notatki.
' Wypisanie notatki odbywa się poprzez ToString() w notatce, więc tu będzie void
class MenedżerNotatek <<Singleton>> {
    - instancja: MenedżerNotatek
    - fabryka: FabrykaNotatek
    - notatki: List<Notatka>
    - IDNotatek: HashSet<int>

    - MenedżerNotatek()
    + UtwórzNotatkęPrzezFabrykę(tytuł: string, treść: string, tagi: List<string>): void
    + WybierzIDNotatki(): int
    + UsuńNotatkę(notatka: Notatka): void
        'po podaniu notatki-obiektu, metoda wzywa ToString() danej notatki i wypisuje jej zawartość
    + DodajTagDoNotatki(notatka: Notatka, tag: Tag)
    + UsuńTagZNotatki(notatka: Notatka, tag: Tag)
        'wyszukiwanie po ID
    + WyszukajNotatke(id: int): Notatka
        'wyszukiwanie po treści - zawiera jednego z podanych stringów
    + WyszukajNotatke(zawiera: List<string>): List<Notatka>
        'wyszukiwanie po Tagu
    + WyszukajNotatke(danyTag: Tag): List<Notatka>
    + WypiszNotatkę(notatka: Notatka): void
    + WypiszNotatki(): void
    + GetterInstancji(): MenedżerNotatek
}

' Fabryka Notatek - dziedziczy z abstrakcyjnej FabrykiWpisów
class FabrykaNotatek <<Factory Method>> {
    + UtwórzWpis(tytuł: string, treść: string, nazwyTagów: List<string>): Notatka <<override>>
}

' Dziedziczy z klasy Wpis
class Notatka {
    - Ulubiona: bool

    + Notatka(tytuł: string, treść: string, tagi: List<Tag>) : base(tytuł: string, treść: string)
    + UstawUlubione(ustawienie: bool): void
    + WypiszInformacje(): string <<override>>
}

' Menedżer zadań - tworzy, usuwa, wyszukuje zadania.
' Wyszukać można po ID, po treści notatki (w tym po tytule, to jedna funkcja!),
' po tagach danej notatki
class MenedżerZadań <<Singleton>> {
    - instancja: MenedżerZadań
    - fabryka: FabrykaZadań
    - zadania: List<Zadanie>
    - IDZadań: HashSet

    - MenedżerZadań()
    + GetterInstancji(): MenedżerZadań
    + UtwórzZadaniePrzezFabrykę(tytuł: string, treść: string, priorytet: Priorytet, termin: Date, tagi: List<string>): void
    + WybierzIDZadania(): int
    + DodajZadanie(zadanie: Zadanie): void
    + UsuńZadanie(zadanie: Zadanie): void
    + DodajTagDoZadania(zadanie: Zadanie, tag: Tag): bool
    + UsuńTagZZadania(zadanie: Zadanie, tag: Tag): bool
    + WypiszZadanie(zadanie: Zadanie): void
    + WyszukajZadanie(id: int): Zadanie
    + SzukajZadań(fraza: string): List<Zadanie>
    + SzukajPoTerminach(od: DateTime, doDaty: DateTime): List<Zadania>
    + SortujZadaniaPoPriorytecie(lista: List<Zadanie>): List<Zadania>
    + OznaczZadaniaJakoWykonane(lista: List<Zadanie>): void
    + WybierzZaległe(): List<Zadanie>
    + WypiszZadania(): void
}

' Fabryka Zadań - dziedziczy z abstrakcyjnej FabrykiWpisów
class FabrykaZadań <<Factory Method>> {
    + FabrykaZadań() : FabrykaWpisów
    + UtwórzWpis(tytuł: string, treść: string, priorytet: Priorytet, termin: Date, nazwyTagów: List<string>): Zadanie <<override>>
}

' Dziedziczy z klasy Wpis
class Zadanie {
    - stan: IStanZadania
    - priorytet: Priorytet
    - termin: DateTime

    + Zadanie(stan: StanZadania, priorytet: Priorytet, termin: Date, tagi: List<Tag>) : base(tytuł: string, treść: string)
    + Zadanie(tytuł: string, treść: string)
    + Edytuj(tytuł: string, treść: string, priorytet: Priorytet, termin: Date): void <<override>>
    + ZwróćStan(): string
    + ZmieńStan(stan: IStanZadania): void
    + OznaczJakoWykonane(): void
    + OznaczJakoAktywne(): void
    + OznaczJakoZaległe(): void
    + SprawdźCzyZalegle(): bool
    + WypiszInformacje(): string <<override>>
}

' Builder klasy Zadanie - interfejs
interface IZadanieBuilder <<Builder>> {
    + UstawTytuł(tytuł: string): ZadanieBuilder
    + UstawTreść(treść: string): ZadanieBuilder
    + UstawStan(stan: StanZadania): ZadanieBuilder
    + UstawPriorytet(priorytet: Priorytet): ZadanieBuilder
    + UstawTermin(termin: DateTime): ZadanieBuilder
    + UstawTagi(tagi: List<string>): ZadanieBuilder
}

' Implementacja Buildera
class ZadanieBuilder <<Builder>> {
    - _zadanie: Zadanie
    
    + UstawTytuł(tytuł: string): ZadanieBuilder
    + UstawTreść(treść: string): ZadanieBuilder
    + UstawStan(stan: IStanZadania): ZadanieBuilder
    + UstawPriorytet(priorytet: Priorytet): ZadanieBuilder
    + UstawTermin(termin: DateTime): ZadanieBuilder
    + UstawTagi(tagi: List<string>): ZadanieBuilder
    + Build(): Zadanie
}

' Director Buildera
class ZadanieDirector <<Director>> {
    - _builder: ZadanieBuilder

    + KonstruujZadaniePilne(tytuł: string, treść: string): void
    + KonstruujZadanieDługoterminowe(tytuł: string, treść: string): void
    + KonstruujZadanieKrótkoterminowe(tytuł: string, treść: string): void
}



' Menedżer tagów tworzy je, usuwa, ma listę wszystkich unikalnych tagów.
class MenedżerTagów <<Singleton>> {
    - instancja: MenedżerTagów
    - tagi: List<Tag>

    - MenedżerTagów()
    + GetterInstancji(): MenedżerTagów
    + UtwórzTag(nazwa: string): void
    + ZwróćTag(nazwa: string): tag
    + UsuńTag(nazwa: string): void
    + DodajWpisDoTagu(tag: Tag, wpis: Wpis): bool
    + UsuńWpisZTagu(tag: Tag, wpis: Wpis): bool
    + WypiszTagi(): void
}

' Tagi mają listy Notatek i Zadań do których są przypisane.
' Jeden tag może zostać przypisany do wielu Notatek i Zadań
class Tag {
    - nazwa: string
    - wpisy: List<Wpis>

    + Tag(nazwa: string)
    + DodajWpis(wpis: Wpis): bool
    + UsuńWpis(wpis: Wpis): bool
}

' DEKORATORY
' Bazowy abstrakcyjny dekorator Wpisów - pozostałe dekoratory z niego dziedziczą
abstract class DekoratorWpisów <<Dekorator>> {
    # wpis: IWpis

    # DekoratorWpisów(wpis: IWpis): IWpis
    + WypiszInformacje(): string
}

' Konkretny dekorator wypisujący Tagi danego Wpisu (Notatki/Zadania)
class DekoratorTagowy <<Dekorator>> {
    + DekoratorTagowy(wpis: IWpis) : base(wpis)
    + WypiszInformacje(): string <<override>>
}


' Abstrakcyjny dekorator działający tylko dla Zadań
abstract class DekoratorZadań <<Dekorator>> {
    # zadanie: Zadanie

    # DekoratorZadań(zadanie: Zadanie) : base(zadanie)
}

' Konkretny dekorator działający tylko dla Zadań - dodaje Stan do WypiszInformacje()
class DekoratorStanowy <<Dekorator>> {
    - stan: StanZadania

    + DekoratorStanowy(zadanie: Zadanie, stan: StanZadania) : base(zadanie)
    + WypiszInformacje(): string <<override>>
}


' STANY
' Dostępne stany dla Zadanie
interface IStanZadania <<State>> {
    + wykonane(zadanie: Zadanie)
    + aktywne(zadanie: Zadanie)
    + zaległe(zadanie: Zadanie)
}

' Konkretne stany 
class StanWykonane <<State>> {
    + wykonane(zadanie: Zadanie): void
    + aktywne(zadanie: Zadanie): void
    + zaległe(zadanie: Zadanie): void
}
class StanAktywne <<State>> {
    + wykonane(zadanie: Zadanie): void
    + aktywne(zadanie: Zadanie): void
    + zaległe(zadanie: Zadanie): void
}
class StanZaległe <<State>> {
    + wykonane(zadanie: Zadanie): void
    + aktywne(zadanie: Zadanie): void
    + zaległe(zadanie: Zadanie): void
}



' RELACJE

' Połączenie między Menedżerami a ich obiektami (kompozycja)
MenedżerNotatek "1" *-- "0..*" Notatka
MenedżerZadań "1" *-- "0..*" Zadanie
MenedżerTagów "1" *-- "0..*" Tag

' Wpis dziedziczy po Interfejsie IWpis
IWpis <|-- Wpis

' Zadanie i Notatka dziedziczą z klasy Wpis
Wpis <|-- Notatka : dziedziczy
Wpis <|-- Zadanie : dziedziczy

' Konkretne Fabryki Notatek i Zadań dziedziczą z abstrakcyjnej FabrykiWpisów
FabrykaWpisów <|-- FabrykaNotatek : dziedziczy
FabrykaWpisów <|-- FabrykaZadań : dziedziczy

' Połączenie Fabryk i ich produktów
FabrykaNotatek ..> Notatka : tworzy
FabrykaZadań ..> Zadanie : tworzy

' Połączenie Fabryk z Menedżerami
MenedżerNotatek ..> FabrykaNotatek : korzysta
MenedżerZadań ..> FabrykaZadań : może używać

' Połączenie tagów i Notatek/Zadań
Notatka "0..*" -- "0..*" Tag
Zadanie "0..*" -- "0..*" Tag

' Enumerator
Zadanie ..> Priorytet : używa

' DEKORATORY
' Abstrakcyjny DekoratorWpisów dziedziczy po IWpisie
IWpis <|-- DekoratorWpisów : dziedziczy
' Konkretny DekoratorTagowy dziedziczy po ogólnym DekoratorzeWpisów
DekoratorWpisów <|-- DekoratorTagowy : dziedziczy
' Ogólny DekoratorZadań dziedziczy po ogólnym DekoratorzeWpisów
DekoratorWpisów <|-- DekoratorZadań : dziedziczy
' Konkretny DekoratorStanowy dziedziczy po ogólnym DekoratorZadań
DekoratorZadań <|-- DekoratorStanowy : dziedziczy


' STANY
' Możliwe stany
Zadanie <|.. StanAktywne
Zadanie <|.. StanWykonane
Zadanie <|.. StanZaległe
Zadanie --> IStanZadania : ma


' BUILDER
IZadanieBuilder <|-- ZadanieBuilder
ZadanieBuilder --> Zadanie : "buduje"
ZadanieDirector --> ZadanieBuilder : "korzysta"


@enduml